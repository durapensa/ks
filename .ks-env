#!/usr/bin/env bash
# Knowledge System Environment Configuration
# Source this file in all tools: source "$(dirname "$0")/../../.ks-env"

# Base directories
export KS_ROOT="${KS_ROOT:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"
export KS_KNOWLEDGE_DIR="${KS_KNOWLEDGE_DIR:-$KS_ROOT/knowledge}"
export KS_TOOLS_DIR="$KS_ROOT/tools"
export KS_EVENTS_DIR="$KS_KNOWLEDGE_DIR/events"
export KS_DERIVED_DIR="$KS_KNOWLEDGE_DIR/derived"

# File paths
export KS_HOT_LOG="$KS_EVENTS_DIR/hot.jsonl"
export KS_ARCHIVE_DIR="$KS_EVENTS_DIR/archive"
export KS_NOTIFICATIONS_DIR="$KS_KNOWLEDGE_DIR/.notifications"

# Claude model for analysis tools
export KS_MODEL="${KS_MODEL:-sonnet}"

# Common functions
ks_ensure_dirs() {
    # Ensure all required directories exist
    mkdir -p "$KS_EVENTS_DIR" "$KS_ARCHIVE_DIR" "$KS_DERIVED_DIR" "$KS_NOTIFICATIONS_DIR"
}

ks_timestamp() {
    # Generate UTC timestamp in ISO format
    date -u '+%Y-%m-%dT%H:%M:%SZ'
}

ks_validate_event_type() {
    local type="$1"
    case "$type" in
        thought|connection|question|insight|process)
            return 0
            ;;
        *)
            echo "Error: Invalid event type '$type'" >&2
            echo "Valid types: thought, connection, question, insight, process" >&2
            return 1
            ;;
    esac
}

ks_claude() {
    # Wrapper for Claude CLI that unwraps the result
    # Usage: ks_claude [claude options] "prompt"
    # Returns just the actual content, not the metadata wrapper
    
    local result
    result=$(claude "$@")
    
    # Check if it's a wrapped result
    if echo "$result" | jq -e '.result' >/dev/null 2>&1; then
        # Extract the actual result content
        echo "$result" | jq -r '.result'
    else
        # Return as-is if not wrapped
        echo "$result"
    fi
}

ks_collect_files() {
    # Collect JSONL files in chronological order (hot log first, then archives)
    # Usage: ks_collect_files
    # Outputs: Array of file paths via global FILES_TO_PROCESS variable
    
    FILES_TO_PROCESS=()
    
    # Add hot log if it exists and has content
    if [ -f "$KS_HOT_LOG" ] && [ -s "$KS_HOT_LOG" ]; then
        FILES_TO_PROCESS+=("$KS_HOT_LOG")
    fi
    
    # Add archive files in reverse chronological order
    if [ -d "$KS_ARCHIVE_DIR" ]; then
        while IFS= read -r -d '' file; do
            if [ -f "$file" ] && [ -s "$file" ]; then
                FILES_TO_PROCESS+=("$file")
            fi
        done < <(find "$KS_ARCHIVE_DIR" -name "*.jsonl" -type f -print0 | sort -zr)
    fi
}

ks_validate_days() {
    # Validate --days parameter is a positive integer
    # Usage: ks_validate_days "$DAYS"
    local days="$1"
    
    if ! [[ "$days" =~ ^[0-9]+$ ]] || [ "$days" -le 0 ]; then
        echo "Error: --days must be a positive integer, got: '$days'" >&2
        return 1
    fi
    
    # Reasonable upper limit to prevent accidents
    if [ "$days" -gt 3650 ]; then
        echo "Warning: --days value '$days' is unusually large (>10 years)" >&2
    fi
    
    return 0
}

ks_sanitize_string() {
    # Basic sanitization for user input to prevent command injection
    # Usage: CLEAN_VAR=$(ks_sanitize_string "$USER_INPUT")
    local input="$1"
    
    # Remove or escape potentially dangerous characters
    # Allow alphanumeric, spaces, hyphens, underscores, periods, colons
    echo "$input" | sed 's/[^a-zA-Z0-9 \-_.:\/]//g'
}

# Initialize on source
ks_ensure_dirs