#!/usr/bin/env bash
# Knowledge System Environment Configuration
# Source this file in all tools: source "$(dirname "$0")/../../.ks-env"

# Base directories
export KS_ROOT="${KS_ROOT:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"
export KS_KNOWLEDGE_DIR="${KS_KNOWLEDGE_DIR:-$KS_ROOT/knowledge}"
export KS_TOOLS_DIR="$KS_ROOT/tools"
export KS_EVENTS_DIR="$KS_KNOWLEDGE_DIR/events"
export KS_DERIVED_DIR="$KS_KNOWLEDGE_DIR/derived"

# File paths
export KS_HOT_LOG="$KS_EVENTS_DIR/hot.jsonl"
export KS_ARCHIVE_DIR="$KS_EVENTS_DIR/archive"
export KS_NOTIFICATIONS_DIR="$KS_KNOWLEDGE_DIR/.notifications"
export KS_BACKGROUND_DIR="$KS_KNOWLEDGE_DIR/.background"
export KS_PROCESS_REGISTRY="$KS_BACKGROUND_DIR/processes"

# Claude model for analysis tools
export KS_MODEL="${KS_MODEL:-sonnet}"

# Common functions
ks_ensure_dirs() {
    # Ensure all required directories exist
    mkdir -p "$KS_EVENTS_DIR" "$KS_ARCHIVE_DIR" "$KS_DERIVED_DIR" "$KS_NOTIFICATIONS_DIR"
    mkdir -p "$KS_PROCESS_REGISTRY"/{active,completed,failed}
}

ks_timestamp() {
    # Generate UTC timestamp in ISO format
    date -u '+%Y-%m-%dT%H:%M:%SZ'
}

ks_validate_event_type() {
    local type="$1"
    case "$type" in
        thought|connection|question|insight|process)
            return 0
            ;;
        *)
            echo "Error: Invalid event type '$type'" >&2
            echo "Valid types: thought, connection, question, insight, process" >&2
            return 1
            ;;
    esac
}

ks_claude() {
    # Wrapper for Claude CLI that unwraps the result
    # Usage: ks_claude [claude options] "prompt"
    # Returns just the actual content, not the metadata wrapper
    
    local result
    result=$(claude "$@")
    
    # Check if it's a wrapped result
    if echo "$result" | jq -e '.result' >/dev/null 2>&1; then
        # Extract the actual result content
        echo "$result" | jq -r '.result'
    else
        # Return as-is if not wrapped
        echo "$result"
    fi
}

ks_collect_files() {
    # Collect JSONL files in chronological order (hot log first, then archives)
    # Usage: ks_collect_files
    # Outputs: Array of file paths via global FILES_TO_PROCESS variable
    
    FILES_TO_PROCESS=()
    
    # Add hot log if it exists and has content
    if [ -f "$KS_HOT_LOG" ] && [ -s "$KS_HOT_LOG" ]; then
        FILES_TO_PROCESS+=("$KS_HOT_LOG")
    fi
    
    # Add archive files in reverse chronological order
    if [ -d "$KS_ARCHIVE_DIR" ]; then
        while IFS= read -r -d '' file; do
            if [ -f "$file" ] && [ -s "$file" ]; then
                FILES_TO_PROCESS+=("$file")
            fi
        done < <(find "$KS_ARCHIVE_DIR" -name "*.jsonl" -type f -print0 | sort -zr)
    fi
}

ks_validate_days() {
    # Validate --days parameter is a positive integer
    # Usage: ks_validate_days "$DAYS"
    local days="$1"
    
    if ! [[ "$days" =~ ^[0-9]+$ ]] || [ "$days" -le 0 ]; then
        echo "Error: --days must be a positive integer, got: '$days'" >&2
        return 1
    fi
    
    # Reasonable upper limit to prevent accidents
    if [ "$days" -gt 3650 ]; then
        echo "Warning: --days value '$days' is unusually large (>10 years)" >&2
    fi
    
    return 0
}

ks_sanitize_string() {
    # Basic sanitization for user input to prevent command injection
    # Usage: CLEAN_VAR=$(ks_sanitize_string "$USER_INPUT")
    local input="$1"
    
    # Remove or escape potentially dangerous characters
    # Allow alphanumeric, spaces, hyphens, underscores, periods, colons
    echo "$input" | sed 's/[^a-zA-Z0-9 \-_.:\/]//g'
}

ks_check_background_results() {
    # Check for and display background analysis notifications
    # Usage: ks_check_background_results
    # Returns: 0 if notifications displayed, 1 if none found
    
    if [ ! -d "$KS_NOTIFICATIONS_DIR" ]; then
        return 1
    fi
    
    # Find recent notifications (last 7 days)
    local notifications=$(find "$KS_NOTIFICATIONS_DIR" -name "*.md" -mtime -7 2>/dev/null | sort)
    
    if [ -z "$notifications" ]; then
        return 1
    fi
    
    echo ""
    echo "=== Background Analysis Results ==="
    local count=0
    for notification in $notifications; do
        if [ -f "$notification" ] && [ -s "$notification" ]; then
            echo ""
            echo "ðŸ“‹ $(basename "$notification" .md)"
            echo "$(head -20 "$notification" | tail -n +3)"  # Skip title, show summary
            echo ""
            count=$((count + 1))
        fi
    done
    
    if [ "$count" -gt 0 ]; then
        echo "Use 'tools/plumbing/cleanup-stale-notifications' to archive these results."
        echo "==================================="
        echo ""
        return 0
    fi
    
    return 1
}

ks_acquire_background_lock() {
    # Acquire exclusive lock for background processing
    # Usage: ks_acquire_background_lock
    # Returns: 0 if lock acquired, 1 if lock exists (another process running)
    
    local lock_file="$KS_BACKGROUND_DIR/background.lock"
    local lock_timeout=300  # 5 minutes
    
    # Check if lock exists and is recent
    if [ -f "$lock_file" ]; then
        local lock_age=$(( $(date +%s) - $(stat -c %Y "$lock_file" 2>/dev/null || stat -f %m "$lock_file" 2>/dev/null || echo 0) ))
        
        if [ "$lock_age" -lt "$lock_timeout" ]; then
            # Lock is recent, another process is likely running
            return 1
        else
            # Stale lock, remove it
            rm -f "$lock_file"
        fi
    fi
    
    # Acquire lock
    echo "$$:$(date +%s):$(whoami)" > "$lock_file"
    return 0
}

ks_release_background_lock() {
    # Release background processing lock
    # Usage: ks_release_background_lock
    
    local lock_file="$KS_BACKGROUND_DIR/background.lock"
    rm -f "$lock_file"
}

ks_register_background_process() {
    # Register a running background process
    # Usage: ks_register_background_process <task_name> <pid> [description]
    
    local task_name="$1"
    local pid="$2"
    local description="${3:-}"
    
    local process_file="$KS_PROCESS_REGISTRY/active/${task_name}-${pid}.json"
    
    cat > "$process_file" << EOF
{
  "task": "$task_name",
  "pid": $pid,
  "start_time": "$(ks_timestamp)",
  "start_epoch": $(date +%s),
  "description": "$description",
  "status": "running"
}
EOF
}

ks_complete_background_process() {
    # Mark a background process as completed
    # Usage: ks_complete_background_process <task_name> <pid> <status> [output_file]
    
    local task_name="$1"
    local pid="$2"
    local status="$3"  # success or failed
    local output_file="${4:-}"
    
    local active_file="$KS_PROCESS_REGISTRY/active/${task_name}-${pid}.json"
    local target_dir="$KS_PROCESS_REGISTRY/$status"
    local target_file="$target_dir/${task_name}-${pid}.json"
    
    if [ -f "$active_file" ]; then
        # Add completion information
        local temp_file=$(mktemp)
        jq --arg end_time "$(ks_timestamp)" \
           --arg end_epoch "$(date +%s)" \
           --arg status "$status" \
           --arg output "$output_file" \
           '. + {end_time: $end_time, end_epoch: ($end_epoch | tonumber), status: $status, output_file: $output}' \
           "$active_file" > "$temp_file"
        
        mv "$temp_file" "$target_file"
        rm -f "$active_file"
    fi
}

ks_cleanup_stale_processes() {
    # Clean up stale process entries
    # Usage: ks_cleanup_stale_processes
    
    local stale_timeout=1800  # 30 minutes
    local current_time=$(date +%s)
    
    for process_file in "$KS_PROCESS_REGISTRY/active"/*.json; do
        if [ -f "$process_file" ]; then
            local start_epoch=$(jq -r '.start_epoch // 0' "$process_file")
            local age=$((current_time - start_epoch))
            
            if [ "$age" -gt "$stale_timeout" ]; then
                local task_name=$(jq -r '.task' "$process_file")
                local pid=$(jq -r '.pid' "$process_file")
                
                # Move to failed directory
                ks_complete_background_process "$task_name" "$pid" "failed"
            fi
        fi
    done
}

# Initialize on source
ks_ensure_dirs