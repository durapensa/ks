#!/usr/bin/env bash
# Knowledge System Environment Configuration
# Source this file in all tools: source "$(dirname "$0")/../../.ks-env"

# Base directories
export KS_ROOT="${KS_ROOT:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"
export KS_KNOWLEDGE_DIR="${KS_KNOWLEDGE_DIR:-$KS_ROOT/knowledge}"
export KS_TOOLS_DIR="$KS_ROOT/tools"
export KS_EVENTS_DIR="$KS_KNOWLEDGE_DIR/events"
export KS_DERIVED_DIR="$KS_KNOWLEDGE_DIR/derived"

# File paths
export KS_HOT_LOG="$KS_EVENTS_DIR/hot.jsonl"
export KS_ARCHIVE_DIR="$KS_EVENTS_DIR/archive"
export KS_BACKGROUND_DIR="$KS_KNOWLEDGE_DIR/.background"
export KS_PROCESS_REGISTRY="$KS_BACKGROUND_DIR/processes"
export KS_ANALYSIS_QUEUE="$KS_BACKGROUND_DIR/analysis_queue.json"

# Claude model for analysis tools
export KS_MODEL="${KS_MODEL:-sonnet}"

# Common functions
ks_ensure_dirs() {
    # Ensure all required directories exist
    mkdir -p "$KS_EVENTS_DIR" "$KS_ARCHIVE_DIR" "$KS_DERIVED_DIR"
    mkdir -p "$KS_PROCESS_REGISTRY"/{active,completed,failed}
    mkdir -p "$KS_BACKGROUND_DIR"/findings
}

ks_timestamp() {
    # Generate UTC timestamp in ISO format
    date -u '+%Y-%m-%dT%H:%M:%SZ'
}

ks_validate_event_type() {
    local type="$1"
    case "$type" in
        thought|connection|question|insight|process)
            return 0
            ;;
        *)
            echo "Error: Invalid event type '$type'" >&2
            echo "Valid types: thought, connection, question, insight, process" >&2
            return 1
            ;;
    esac
}

ks_claude() {
    # Wrapper for Claude CLI that unwraps the result
    # Usage: ks_claude [claude options] "prompt"
    # Returns just the actual content, not the metadata wrapper
    
    local result
    result=$(claude "$@")
    
    # Check if it's a wrapped result
    if echo "$result" | jq -e '.result' >/dev/null 2>&1; then
        # Extract the actual result content
        echo "$result" | jq -r '.result'
    else
        # Return as-is if not wrapped
        echo "$result"
    fi
}

ks_collect_files() {
    # Collect JSONL files in chronological order (hot log first, then archives)
    # Usage: ks_collect_files
    # Outputs: Array of file paths via global FILES_TO_PROCESS variable
    
    FILES_TO_PROCESS=()
    
    # Add hot log if it exists and has content
    if [ -f "$KS_HOT_LOG" ] && [ -s "$KS_HOT_LOG" ]; then
        FILES_TO_PROCESS+=("$KS_HOT_LOG")
    fi
    
    # Add archive files in reverse chronological order
    if [ -d "$KS_ARCHIVE_DIR" ]; then
        while IFS= read -r -d '' file; do
            if [ -f "$file" ] && [ -s "$file" ]; then
                FILES_TO_PROCESS+=("$file")
            fi
        done < <(find "$KS_ARCHIVE_DIR" -name "*.jsonl" -type f -print0 | sort -zr)
    fi
}

ks_validate_days() {
    # Validate --days parameter is a positive integer
    # Usage: ks_validate_days "$DAYS"
    local days="$1"
    
    if ! [[ "$days" =~ ^[0-9]+$ ]] || [ "$days" -le 0 ]; then
        echo "Error: --days must be a positive integer, got: '$days'" >&2
        return 1
    fi
    
    # Reasonable upper limit to prevent accidents
    if [ "$days" -gt 3650 ]; then
        echo "Warning: --days value '$days' is unusually large (>10 years)" >&2
    fi
    
    return 0
}

ks_sanitize_string() {
    # Basic sanitization for user input to prevent command injection
    # Usage: CLEAN_VAR=$(ks_sanitize_string "$USER_INPUT")
    local input="$1"
    
    # Remove or escape potentially dangerous characters
    # Allow alphanumeric, spaces, hyphens, underscores, periods, colons
    echo "$input" | sed 's/[^a-zA-Z0-9 \-_.:\/]//g'
}

ks_check_background_results() {
    # Check for pending analyses in queue and display notification
    # Usage: ks_check_background_results
    # Returns: 0 if notifications displayed, 1 if none found
    
    # Initialize queue if needed
    ks_queue_init
    
    # Check for pending analyses
    local pending=$(ks_queue_list_pending)
    
    if [ "$pending" = "[]" ]; then
        return 1
    fi
    
    # Display pending analyses
    echo ""
    echo "=== Background Analyses Ready for Review ==="
    echo ""
    
    local count=$(echo "$pending" | jq -r 'length')
    echo "You have $count analysis/analyses pending review:"
    echo ""
    
    echo "$pending" | jq -r '.[] | "  â€¢ \(.type) - completed at \(.value.completed_at)"'
    
    echo ""
    echo "Run 'tools/analyze/review-findings' in a separate terminal to review."
    echo "============================================"
    echo ""
    
    return 0
}

ks_acquire_background_lock() {
    # Acquire exclusive lock for background processing
    # Usage: ks_acquire_background_lock
    # Returns: 0 if lock acquired, 1 if lock exists (another process running)
    
    local lock_file="$KS_BACKGROUND_DIR/background.lock"
    local lock_timeout=300  # 5 minutes
    
    # Check if lock exists and is recent
    if [ -f "$lock_file" ]; then
        local lock_age=$(( $(date +%s) - $(stat -c %Y "$lock_file" 2>/dev/null || stat -f %m "$lock_file" 2>/dev/null || echo 0) ))
        
        if [ "$lock_age" -lt "$lock_timeout" ]; then
            # Lock is recent, another process is likely running
            return 1
        else
            # Stale lock, remove it
            rm -f "$lock_file"
        fi
    fi
    
    # Acquire lock
    echo "$$:$(date +%s):$(whoami)" > "$lock_file"
    return 0
}

ks_release_background_lock() {
    # Release background processing lock
    # Usage: ks_release_background_lock
    
    local lock_file="$KS_BACKGROUND_DIR/background.lock"
    rm -f "$lock_file"
}

ks_register_background_process() {
    # Register a running background process
    # Usage: ks_register_background_process <task_name> <pid> [description]
    
    local task_name="$1"
    local pid="$2"
    local description="${3:-}"
    
    local process_file="$KS_PROCESS_REGISTRY/active/${task_name}-${pid}.json"
    
    cat > "$process_file" << EOF
{
  "task": "$task_name",
  "pid": $pid,
  "start_time": "$(ks_timestamp)",
  "start_epoch": $(date +%s),
  "description": "$description",
  "status": "running"
}
EOF
}

ks_complete_background_process() {
    # Mark a background process as completed
    # Usage: ks_complete_background_process <task_name> <pid> <status> [output_file]
    
    local task_name="$1"
    local pid="$2"
    local status="$3"  # success or failed
    local output_file="${4:-}"
    
    local active_file="$KS_PROCESS_REGISTRY/active/${task_name}-${pid}.json"
    local target_dir="$KS_PROCESS_REGISTRY/$status"
    local target_file="$target_dir/${task_name}-${pid}.json"
    
    if [ -f "$active_file" ]; then
        # Add completion information
        local temp_file=$(mktemp)
        jq --arg end_time "$(ks_timestamp)" \
           --arg end_epoch "$(date +%s)" \
           --arg status "$status" \
           --arg output "$output_file" \
           '. + {end_time: $end_time, end_epoch: ($end_epoch | tonumber), status: $status, output_file: $output}' \
           "$active_file" > "$temp_file"
        
        mv "$temp_file" "$target_file"
        rm -f "$active_file"
    fi
}

ks_cleanup_stale_processes() {
    # Clean up stale process entries
    # Usage: ks_cleanup_stale_processes
    
    local stale_timeout=1800  # 30 minutes
    local current_time=$(date +%s)
    
    for process_file in "$KS_PROCESS_REGISTRY/active"/*.json; do
        if [ -f "$process_file" ]; then
            local start_epoch=$(jq -r '.start_epoch // 0' "$process_file")
            local age=$((current_time - start_epoch))
            
            if [ "$age" -gt "$stale_timeout" ]; then
                local task_name=$(jq -r '.task' "$process_file")
                local pid=$(jq -r '.pid' "$process_file")
                
                # Move to failed directory
                ks_complete_background_process "$task_name" "$pid" "failed"
            fi
        fi
    done
}

ks_queue_init() {
    # Initialize analysis queue if it doesn't exist
    # Usage: ks_queue_init
    
    if [ ! -f "$KS_ANALYSIS_QUEUE" ]; then
        echo '{"analyses": {}}' > "$KS_ANALYSIS_QUEUE"
    fi
}

ks_queue_check() {
    # Check if an analysis type has pending review
    # Usage: ks_queue_check <analysis_type>
    # Returns: 0 if clear to run, 1 if pending review
    
    local analysis_type="$1"
    ks_queue_init
    
    local status=$(jq -r ".analyses.\"$analysis_type\".status // \"none\"" "$KS_ANALYSIS_QUEUE")
    
    if [ "$status" = "pending_review" ]; then
        return 1  # Cannot run - has pending review
    fi
    return 0  # Clear to run
}

ks_queue_add_pending() {
    # Add analysis to queue as pending review
    # Usage: ks_queue_add_pending <analysis_type> <findings_file>
    
    local analysis_type="$1"
    local findings_file="$2"
    ks_queue_init
    
    local temp_file=$(mktemp)
    jq --arg type "$analysis_type" \
       --arg file "$findings_file" \
       --arg time "$(ks_timestamp)" \
       '.analyses[$type] = {status: "pending_review", findings_file: $file, completed_at: $time}' \
       "$KS_ANALYSIS_QUEUE" > "$temp_file"
    
    mv "$temp_file" "$KS_ANALYSIS_QUEUE"
}

ks_queue_clear() {
    # Clear analysis from queue after review
    # Usage: ks_queue_clear <analysis_type>
    
    local analysis_type="$1"
    ks_queue_init
    
    local temp_file=$(mktemp)
    jq --arg type "$analysis_type" \
       'del(.analyses[$type])' \
       "$KS_ANALYSIS_QUEUE" > "$temp_file"
    
    mv "$temp_file" "$KS_ANALYSIS_QUEUE"
}

ks_queue_list_pending() {
    # List all analyses pending review
    # Usage: ks_queue_list_pending
    # Output: JSON array of pending analyses
    
    ks_queue_init
    jq -r '.analyses | to_entries | map(select(.value.status == "pending_review")) | map({type: .key, value: .value})' "$KS_ANALYSIS_QUEUE"
}

ks_count_new_events() {
    # Count events added since a given timestamp
    # Usage: ks_count_new_events [since_timestamp]
    # If no timestamp provided, counts all events
    
    local since="${1:-}"
    local count=0
    
    if [ -f "$KS_HOT_LOG" ]; then
        if [ -n "$since" ]; then
            # Count events newer than timestamp
            count=$(awk -F'"timestamp":"' -v since="$since" '
                $2 {
                    gsub(/".*/, "", $2)
                    if ($2 > since) count++
                }
                END { print count }
            ' "$KS_HOT_LOG")
        else
            # Count all events
            count=$(wc -l < "$KS_HOT_LOG")
        fi
    fi
    
    echo "$count"
}

# Initialize on source
ks_ensure_dirs