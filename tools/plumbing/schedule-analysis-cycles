#!/bin/bash
# Schedule and execute background analysis cycles with cost controls
# Runs small, focused analysis tasks and curates results for quality

set -euo pipefail

# Source environment
source "$(dirname "$0")/../../.ks-env"

# Check for background analysis results
ks_check_background_results || true  # Don't fail if no notifications

# Configuration
KS_BG_STATE="$KS_KNOWLEDGE_DIR/.background/state"
KS_BG_LOG="$KS_KNOWLEDGE_DIR/.background/analysis.log"
KS_BG_BUDGET="${KS_ANALYSIS_BUDGET:-0.50}"        # Daily budget in USD
KS_MIN_EVENTS="${KS_MIN_EVENTS_FOR_ANALYSIS:-5}"  # Minimum events to trigger analysis

# Ensure background directory exists
mkdir -p "$(dirname "$KS_BG_STATE")"

# Usage information
usage() {
    cat << EOF
Usage: $(basename "$0") [options]

Schedule and execute background analysis cycles with intelligent
triggering and cost controls.

Options:
  --run             Execute one analysis cycle now
  --daemon          Run continuously, checking every hour
  --status          Show current background processing status
  --reset           Reset all background processing state
  --force           Force analysis regardless of budget/events
  --test            Run with test data to verify functionality
  --install-launchd Install as macOS launchd service
  --help            Show this help message

Background processing runs:
  - Theme analysis when enough new events accumulate
  - Knowledge curation to prevent duplicates
  - Smart cost tracking within daily budget

Configuration (environment variables):
  KS_ANALYSIS_BUDGET     Daily budget in USD (default: $KS_BG_BUDGET)
  KS_MIN_EVENTS_FOR_ANALYSIS  Min events to trigger (default: $KS_MIN_EVENTS)

Examples:
  $(basename "$0") --run       # Execute one cycle now
  $(basename "$0") --status    # Check what would run
  $(basename "$0") --test      # Test with known data
EOF
}

# Logging
bg_log() {
    local message="$*"
    echo "[$(ks_timestamp)] $message" | tee -a "$KS_BG_LOG"
}

# State management
load_state() {
    if [ -f "$KS_BG_STATE" ]; then
        source "$KS_BG_STATE"
    else
        # Initialize state
        LAST_THEME_ANALYSIS=""
        LAST_CONNECTION_ANALYSIS=""
        DAILY_COST_SPENT="0.00"
        COST_DATE=$(date +%Y-%m-%d)
        EVENT_COUNT_AT_LAST_ANALYSIS="0"
    fi
}

save_state() {
    cat > "$KS_BG_STATE" << EOF
# Background processing state - automatically managed
LAST_THEME_ANALYSIS="$LAST_THEME_ANALYSIS"
LAST_CONNECTION_ANALYSIS="$LAST_CONNECTION_ANALYSIS"
DAILY_COST_SPENT="$DAILY_COST_SPENT"
COST_DATE="$COST_DATE"
EVENT_COUNT_AT_LAST_ANALYSIS="$EVENT_COUNT_AT_LAST_ANALYSIS"
EOF
}

# Cost tracking with daily reset
check_budget() {
    local estimated_cost="$1"
    local current_date=$(date +%Y-%m-%d)
    
    # Reset daily budget if new day
    if [ "$COST_DATE" != "$current_date" ]; then
        DAILY_COST_SPENT="0.00"
        COST_DATE="$current_date"
        bg_log "New day: resetting daily cost tracking"
    fi
    
    # Check if we can afford this operation
    local total_cost=$(echo "$DAILY_COST_SPENT + $estimated_cost" | bc -l)
    if (( $(echo "$total_cost > $KS_BG_BUDGET" | bc -l) )); then
        bg_log "Budget exceeded: would spend \$$total_cost > \$$KS_BG_BUDGET daily limit"
        return 1
    fi
    return 0
}

add_cost() {
    local cost="$1"
    DAILY_COST_SPENT=$(echo "$DAILY_COST_SPENT + $cost" | bc -l)
    bg_log "Added cost: \$$cost (total today: \$$DAILY_COST_SPENT)"
}

# Count current events
count_current_events() {
    ks_collect_files
    if [ ${#FILES_TO_PROCESS[@]} -gt 0 ]; then
        cat "${FILES_TO_PROCESS[@]}" 2>/dev/null | wc -l || echo 0
    else
        echo 0
    fi
}

# Check if theme analysis is needed
needs_theme_analysis() {
    local current_events=$(count_current_events)
    local new_events=$((current_events - EVENT_COUNT_AT_LAST_ANALYSIS))
    
    # Need analysis if we have enough new events
    if [ "$new_events" -ge "$KS_MIN_EVENTS" ]; then
        # Also check time since last analysis (minimum 6 hours between runs)
        if [ -n "$LAST_THEME_ANALYSIS" ]; then
            local last_epoch=$(date -d "$LAST_THEME_ANALYSIS" +%s 2>/dev/null || echo 0)
            local current_epoch=$(date +%s)
            local hours_diff=$(( (current_epoch - last_epoch) / 3600 ))
            
            if [ "$hours_diff" -lt 6 ]; then
                bg_log "Theme analysis: too recent (${hours_diff}h ago), skipping"
                return 1
            fi
        fi
        
        bg_log "Theme analysis needed: $new_events new events since last analysis"
        return 0
    fi
    
    bg_log "Theme analysis not needed: only $new_events new events (need $KS_MIN_EVENTS)"
    return 1
}

# Run theme analysis using dedicated analysis tool
run_theme_analysis() {
    bg_log "Starting theme analysis"
    
    # Check budget  
    if ! check_budget "0.15"; then
        bg_log "Skipping theme analysis: budget exceeded"
        return 1
    fi
    
    # Acquire lock for serialization
    if ! ks_acquire_background_lock; then
        bg_log "Background processing lock held by another process, skipping"
        return 1
    fi
    
    # Run analysis in background
    (
        # Register this process
        ks_register_background_process "theme-analysis" $$ "Theme extraction from recent events"
        
        # Collect events and run analysis tool
        ks_collect_files
        local output_file=$(mktemp)
        
        if [ ${#FILES_TO_PROCESS[@]} -gt 0 ]; then
            # Run analysis on real events
            if cat "${FILES_TO_PROCESS[@]}" | \
               timeout 120 tools/analyze/identify-recurring-thought-patterns --days 3 > "$output_file" 2>&1; then
                # Analysis successful
                local themes_output=$(cat "$output_file")
                
                # Curate results to prevent redundancy
                if echo "$themes_output" | tools/analyze/curate-duplicate-knowledge --type themes >/dev/null 2>&1; then
                    # Content is unique, create notification
                    local notification_file="$KS_NOTIFICATIONS_DIR/themes-$(date +%Y%m%d-%H%M%S).md"
                    cat > "$notification_file" << EOF
# Theme Analysis Results

**Generated**: $(ks_timestamp)  
**Scope**: Last 3 days (background analysis)  

## Key Themes Identified

$themes_output

---
*This analysis ran automatically in the background. Use cleanup-stale-notifications to archive when reviewed.*
EOF
                    bg_log "Theme analysis completed, notification created: $(basename "$notification_file")"
                else
                    bg_log "Theme analysis results were redundant, notification skipped"
                fi
                
                ks_complete_background_process "theme-analysis" $$ "completed" "$output_file"
            else
                # Analysis failed
                ks_complete_background_process "theme-analysis" $$ "failed" "$output_file"
            fi
        else
            bg_log "No events available for theme analysis"
            ks_complete_background_process "theme-analysis" $$ "skipped" "No events"
        fi
        
        # Cleanup
        rm -f "$output_file"
        ks_release_background_lock
    ) &
    
    local analysis_pid=$!
    bg_log "Started theme analysis process: PID $analysis_pid (running async)"
    
    # Update state
    LAST_THEME_ANALYSIS=$(ks_timestamp)
    EVENT_COUNT_AT_LAST_ANALYSIS=$(count_current_events)
    
    return 0
}

# Test mode with known data
run_test_analysis() {
    bg_log "Running test analysis mode"
    
    # Create a test notification to verify the pipeline
    local test_notification="$KS_NOTIFICATIONS_DIR/test-analysis-$(date +%Y%m%d-%H%M%S).md"
    cat > "$test_notification" << EOF
# Test Analysis Results

**Generated**: $(ks_timestamp)  
**Scope**: Test mode  
**Cost**: \$0.00 (test)

## Test Results

This is a test notification to verify the background processing pipeline works correctly.

### Test Metrics
- Event count: $(count_current_events)
- Budget remaining: \$$(echo "$KS_BG_BUDGET - $DAILY_COST_SPENT" | bc -l)
- Last analysis: ${LAST_THEME_ANALYSIS:-never}

---
*This is a test notification. Use cleanup-stale-notifications to remove.*
EOF
    
    bg_log "Test notification created: $(basename "$test_notification")"
    return 0
}

# Show status
show_status() {
    load_state
    
    echo "=== Background Processing Status ==="
    echo "Current date: $(date +%Y-%m-%d)"
    local current_events=$(count_current_events)
    echo "Events available: $current_events"
    echo "Events at last analysis: $EVENT_COUNT_AT_LAST_ANALYSIS"
    echo "New events since analysis: $((current_events - EVENT_COUNT_AT_LAST_ANALYSIS))"
    echo ""
    echo "Budget status:"
    echo "  Daily budget: \$$KS_BG_BUDGET"
    echo "  Spent today: \$$DAILY_COST_SPENT"
    echo "  Remaining: \$$(echo "$KS_BG_BUDGET - $DAILY_COST_SPENT" | bc -l)"
    echo ""
    echo "Last analyses:"
    echo "  Themes: ${LAST_THEME_ANALYSIS:-never}"
    echo "  Connections: ${LAST_CONNECTION_ANALYSIS:-never}"
    echo ""
    echo "Analysis triggers:"
    if needs_theme_analysis; then
        echo "  ✓ Theme analysis ready to run"
    else
        echo "  ✗ Theme analysis not needed"
    fi
    echo ""
    echo "Minimum events for analysis: $KS_MIN_EVENTS"
    echo "State file: $KS_BG_STATE"
    echo "Log file: $KS_BG_LOG"
}

# Main processing cycle
run_analysis_cycle() {
    local force_mode="$1"
    
    load_state
    bg_log "Starting analysis cycle (force: $force_mode)"
    
    # Run theme analysis if needed
    if [ "$force_mode" = true ] || needs_theme_analysis; then
        if run_theme_analysis; then
            bg_log "Theme analysis successful"
        else
            bg_log "Theme analysis failed or skipped"
        fi
    fi
    
    # Future: Add calls to other analysis tools:
    # - tools/analyze/surface-deep-connections
    # - tools/analyze/synthesize-emergent-insights
    
    save_state
    bg_log "Analysis cycle completed"
}

# Reset all state
reset_state() {
    echo "Resetting background processing state..."
    rm -f "$KS_BG_STATE"
    echo "State reset. Next run will start fresh."
}

# Daemon mode - run continuously
run_daemon() {
    bg_log "Starting background analysis daemon (PID $$)"
    echo $$ > "$KS_BACKGROUND_DIR/daemon.pid"
    
    trap 'bg_log "Daemon shutting down"; rm -f "$KS_BACKGROUND_DIR/daemon.pid"; exit 0' SIGTERM SIGINT
    
    while true; do
        bg_log "Daemon checking for analysis needs"
        run_analysis_cycle false
        
        # Sleep for 1 hour
        bg_log "Daemon sleeping for 1 hour"
        sleep 3600
    done
}

# Install launchd service for macOS
install_launchd() {
    local plist_name="com.ks.background-analysis"
    local plist_file="$HOME/Library/LaunchAgents/${plist_name}.plist"
    local script_path="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")"
    
    echo "Installing launchd service: $plist_name"
    
    cat > "$plist_file" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>${plist_name}</string>
    <key>ProgramArguments</key>
    <array>
        <string>${script_path}</string>
        <string>--daemon</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <false/>
    <key>StartInterval</key>
    <integer>3600</integer>
    <key>StandardOutPath</key>
    <string>$KS_BACKGROUND_DIR/daemon.log</string>
    <key>StandardErrorPath</key>
    <string>$KS_BACKGROUND_DIR/daemon.error.log</string>
</dict>
</plist>
EOF
    
    echo "Loading service..."
    launchctl load "$plist_file"
    
    echo "Service installed and started!"
    echo "To check status: launchctl list | grep $plist_name"
    echo "To uninstall: launchctl unload $plist_file && rm $plist_file"
}

# Parse arguments
case "${1:-run}" in
    --run|run)
        run_analysis_cycle false
        ;;
    --daemon)
        run_daemon
        ;;
    --force)
        run_analysis_cycle true
        ;;
    --status)
        show_status
        ;;
    --test)
        load_state
        run_test_analysis
        save_state
        ;;
    --reset)
        reset_state
        ;;
    --install-launchd)
        install_launchd
        ;;
    --help)
        usage
        ;;
    *)
        echo "Unknown option: $1" >&2
        usage >&2
        exit 1
        ;;
esac