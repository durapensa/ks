#!/bin/bash
# Schedule and execute background analysis cycles with cost controls
# Runs small, focused analysis tasks and curates results for quality

set -euo pipefail

# Source environment
source "$(dirname "$0")/../../.ks-env"

# Check for background analysis results
ks_check_background_results || true  # Don't fail if no notifications

# Configuration
KS_BG_STATE="$KS_KNOWLEDGE_DIR/.background/state"
KS_BG_LOG="$KS_KNOWLEDGE_DIR/.background/analysis.log"
KS_BG_BUDGET="${KS_ANALYSIS_BUDGET:-0.50}"        # Daily budget in USD
KS_MIN_EVENTS="${KS_MIN_EVENTS_FOR_ANALYSIS:-5}"  # Minimum events to trigger analysis

# Ensure background directory exists
mkdir -p "$(dirname "$KS_BG_STATE")"

# Usage information
usage() {
    cat << EOF
Usage: $(basename "$0") [options]

Schedule and execute background analysis cycles with intelligent
triggering and cost controls.

Options:
  --run             Execute one analysis cycle now
  --status          Show current background processing status
  --reset           Reset all background processing state
  --force           Force analysis regardless of budget/events
  --test            Run with test data to verify functionality
  --help            Show this help message

Background processing runs:
  - Theme analysis when enough new events accumulate
  - Knowledge curation to prevent duplicates
  - Smart cost tracking within daily budget

Configuration (environment variables):
  KS_ANALYSIS_BUDGET     Daily budget in USD (default: $KS_BG_BUDGET)
  KS_MIN_EVENTS_FOR_ANALYSIS  Min events to trigger (default: $KS_MIN_EVENTS)

Examples:
  $(basename "$0") --run       # Execute one cycle now
  $(basename "$0") --status    # Check what would run
  $(basename "$0") --test      # Test with known data
EOF
}

# Logging
bg_log() {
    local message="$*"
    echo "[$(ks_timestamp)] $message" | tee -a "$KS_BG_LOG"
}

# State management
load_state() {
    if [ -f "$KS_BG_STATE" ]; then
        source "$KS_BG_STATE"
    else
        # Initialize state
        LAST_THEME_ANALYSIS=""
        LAST_CONNECTION_ANALYSIS=""
        DAILY_COST_SPENT="0.00"
        COST_DATE=$(date +%Y-%m-%d)
        EVENT_COUNT_AT_LAST_ANALYSIS="0"
    fi
}

save_state() {
    cat > "$KS_BG_STATE" << EOF
# Background processing state - automatically managed
LAST_THEME_ANALYSIS="$LAST_THEME_ANALYSIS"
LAST_CONNECTION_ANALYSIS="$LAST_CONNECTION_ANALYSIS"
DAILY_COST_SPENT="$DAILY_COST_SPENT"
COST_DATE="$COST_DATE"
EVENT_COUNT_AT_LAST_ANALYSIS="$EVENT_COUNT_AT_LAST_ANALYSIS"
EOF
}

# Cost tracking with daily reset
check_budget() {
    local estimated_cost="$1"
    local current_date=$(date +%Y-%m-%d)
    
    # Reset daily budget if new day
    if [ "$COST_DATE" != "$current_date" ]; then
        DAILY_COST_SPENT="0.00"
        COST_DATE="$current_date"
        bg_log "New day: resetting daily cost tracking"
    fi
    
    # Check if we can afford this operation
    local total_cost=$(echo "$DAILY_COST_SPENT + $estimated_cost" | bc -l)
    if (( $(echo "$total_cost > $KS_BG_BUDGET" | bc -l) )); then
        bg_log "Budget exceeded: would spend \$$total_cost > \$$KS_BG_BUDGET daily limit"
        return 1
    fi
    return 0
}

add_cost() {
    local cost="$1"
    DAILY_COST_SPENT=$(echo "$DAILY_COST_SPENT + $cost" | bc -l)
    bg_log "Added cost: \$$cost (total today: \$$DAILY_COST_SPENT)"
}

# Count current events
count_current_events() {
    ks_collect_files
    if [ ${#FILES_TO_PROCESS[@]} -gt 0 ]; then
        cat "${FILES_TO_PROCESS[@]}" 2>/dev/null | wc -l || echo 0
    else
        echo 0
    fi
}

# Check if theme analysis is needed
needs_theme_analysis() {
    local current_events=$(count_current_events)
    local new_events=$((current_events - EVENT_COUNT_AT_LAST_ANALYSIS))
    
    # Need analysis if we have enough new events
    if [ "$new_events" -ge "$KS_MIN_EVENTS" ]; then
        # Also check time since last analysis (minimum 6 hours between runs)
        if [ -n "$LAST_THEME_ANALYSIS" ]; then
            local last_epoch=$(date -d "$LAST_THEME_ANALYSIS" +%s 2>/dev/null || echo 0)
            local current_epoch=$(date +%s)
            local hours_diff=$(( (current_epoch - last_epoch) / 3600 ))
            
            if [ "$hours_diff" -lt 6 ]; then
                bg_log "Theme analysis: too recent (${hours_diff}h ago), skipping"
                return 1
            fi
        fi
        
        bg_log "Theme analysis needed: $new_events new events since last analysis"
        return 0
    fi
    
    bg_log "Theme analysis not needed: only $new_events new events (need $KS_MIN_EVENTS)"
    return 1
}

# Run small, focused theme analysis using claude -p
run_theme_analysis() {
    bg_log "Starting theme analysis with claude -p"
    
    # Check budget  
    if ! check_budget "0.15"; then
        bg_log "Skipping theme analysis: budget exceeded"
        return 1
    fi
    
    # Acquire lock for serialization
    if ! ks_acquire_background_lock; then
        bg_log "Background processing lock held by another process, skipping"
        return 1
    fi
    
    # Collect events for analysis
    ks_collect_files
    local input_file=$(mktemp)
    local output_file=$(mktemp)
    
    if [ ${#FILES_TO_PROCESS[@]} -gt 0 ]; then
        # Use last 3 days of events for cost control
        local since_date=$(date -u -d "3 days ago" +%Y-%m-%dT%H:%M:%SZ)
        cat "${FILES_TO_PROCESS[@]}" | jq -r --arg since_date "$since_date" \
            'select(.ts >= $since_date) | .content' > "$input_file"
    else
        # Use test data if no real events
        jq -r '.content' "$KS_BACKGROUND_DIR/test-events.jsonl" > "$input_file"
        bg_log "Using test events for analysis"
    fi
    
    # Check if we have content to analyze
    if [ ! -s "$input_file" ]; then
        bg_log "No content available for theme analysis"
        rm -f "$input_file" "$output_file"
        ks_release_background_lock
        return 1
    fi
    
    bg_log "Running claude -p analysis on $(wc -l < "$input_file") content items"
    
    # Prepare claude prompt
    local prompt="Extract 2-3 key themes from these knowledge events. For each theme, provide:
1. Theme name (concise)
2. Brief description (1-2 sentences)
3. Supporting evidence from the content

Format as JSON with themes array. Focus on patterns and connections rather than isolated thoughts."
    
    # Run claude analysis in background with process tracking
    (
        # Register this process
        ks_register_background_process "theme-analysis" $$ "Theme extraction from recent events"
        
        # Run claude with timeout and capture output
        if timeout 120 claude -p "$prompt" < "$input_file" > "$output_file" 2>&1; then
            # Analysis successful
            ks_complete_background_process "theme-analysis" $$ "completed" "$output_file"
        else
            # Analysis failed
            ks_complete_background_process "theme-analysis" $$ "failed" "$output_file"
            exit 1
        fi
    ) &
    
    local claude_pid=$!
    bg_log "Started claude analysis process: PID $claude_pid"
    
    # Wait for claude process
    if wait $claude_pid; then
        bg_log "Claude analysis completed successfully"
        
        # Check if we have valid output
        if [ -s "$output_file" ]; then
            local themes_output=$(cat "$output_file")
            
            # Curate results to prevent redundancy
            if echo "$themes_output" | tools/analyze/curate-duplicate-knowledge --type themes >/dev/null 2>&1; then
                # Content is unique, create notification
                local notification_file="$KS_NOTIFICATIONS_DIR/themes-$(date +%Y%m%d-%H%M%S).md"
                cat > "$notification_file" << EOF
# Theme Analysis Results

**Generated**: $(ks_timestamp)  
**Scope**: Last 3 days (background analysis)  
**Input**: $(wc -l < "$input_file") content items

## Key Themes Identified

$themes_output

---
*This analysis ran automatically in the background using claude -p. Use cleanup-stale-notifications to archive when processed.*
EOF
                bg_log "Theme analysis completed, notification created: $(basename "$notification_file")"
            else
                bg_log "Theme analysis results were redundant, notification skipped"
            fi
        else
            bg_log "Claude analysis produced no output"
        fi
    else
        bg_log "Claude analysis failed or timed out"
    fi
    
    # Cleanup
    rm -f "$input_file" "$output_file"
    ks_release_background_lock
    
    # Update state
    LAST_THEME_ANALYSIS=$(ks_timestamp)
    EVENT_COUNT_AT_LAST_ANALYSIS=$(count_current_events)
    
    return 0
}

# Test mode with known data
run_test_analysis() {
    bg_log "Running test analysis mode"
    
    # Create a test notification to verify the pipeline
    local test_notification="$KS_NOTIFICATIONS_DIR/test-analysis-$(date +%Y%m%d-%H%M%S).md"
    cat > "$test_notification" << EOF
# Test Analysis Results

**Generated**: $(ks_timestamp)  
**Scope**: Test mode  
**Cost**: \$0.00 (test)

## Test Results

This is a test notification to verify the background processing pipeline works correctly.

### Test Metrics
- Event count: $(count_current_events)
- Budget remaining: \$$(echo "$KS_BG_BUDGET - $DAILY_COST_SPENT" | bc -l)
- Last analysis: ${LAST_THEME_ANALYSIS:-never}

---
*This is a test notification. Use cleanup-stale-notifications to remove.*
EOF
    
    bg_log "Test notification created: $(basename "$test_notification")"
    return 0
}

# Show status
show_status() {
    load_state
    
    echo "=== Background Processing Status ==="
    echo "Current date: $(date +%Y-%m-%d)"
    local current_events=$(count_current_events)
    echo "Events available: $current_events"
    echo "Events at last analysis: $EVENT_COUNT_AT_LAST_ANALYSIS"
    echo "New events since analysis: $((current_events - EVENT_COUNT_AT_LAST_ANALYSIS))"
    echo ""
    echo "Budget status:"
    echo "  Daily budget: \$$KS_BG_BUDGET"
    echo "  Spent today: \$$DAILY_COST_SPENT"
    echo "  Remaining: \$$(echo "$KS_BG_BUDGET - $DAILY_COST_SPENT" | bc -l)"
    echo ""
    echo "Last analyses:"
    echo "  Themes: ${LAST_THEME_ANALYSIS:-never}"
    echo "  Connections: ${LAST_CONNECTION_ANALYSIS:-never}"
    echo ""
    echo "Analysis triggers:"
    if needs_theme_analysis; then
        echo "  ✓ Theme analysis ready to run"
    else
        echo "  ✗ Theme analysis not needed"
    fi
    echo ""
    echo "Minimum events for analysis: $KS_MIN_EVENTS"
    echo "State file: $KS_BG_STATE"
    echo "Log file: $KS_BG_LOG"
}

# Main processing cycle
run_analysis_cycle() {
    local force_mode="$1"
    
    load_state
    bg_log "Starting analysis cycle (force: $force_mode)"
    
    # Run theme analysis if needed
    if [ "$force_mode" = true ] || needs_theme_analysis; then
        if run_theme_analysis; then
            bg_log "Theme analysis successful"
        else
            bg_log "Theme analysis failed or skipped"
        fi
    fi
    
    # TODO: Add connection analysis, insight generation, etc.
    
    save_state
    bg_log "Analysis cycle completed"
}

# Reset all state
reset_state() {
    echo "Resetting background processing state..."
    rm -f "$KS_BG_STATE"
    echo "State reset. Next run will start fresh."
}

# Parse arguments
case "${1:-run}" in
    --run|run)
        run_analysis_cycle false
        ;;
    --force)
        run_analysis_cycle true
        ;;
    --status)
        show_status
        ;;
    --test)
        load_state
        run_test_analysis
        save_state
        ;;
    --reset)
        reset_state
        ;;
    --help)
        usage
        ;;
    *)
        echo "Unknown option: $1" >&2
        usage >&2
        exit 1
        ;;
esac