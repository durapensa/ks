#!/usr/bin/env bash

# kq (knowledge-query) - Search across events and knowledge

set -euo pipefail

# Source configuration and modular libraries
source "${0%/*}/../../.ks-env"
source "$KS_ROOT/lib/core.sh"
source "$KS_ROOT/lib/files.sh"
source "$KS_ROOT/lib/time.sh"
source "$KS_ROOT/lib/argparse.sh"
source "$KS_ROOT/tools/lib/queue.sh"

# Usage function
usage() {
    echo "Usage: kq <search_term> [options]"
    echo ""
    echo "Options:"
    echo "  --type TYPE      Filter by event type"
    echo "  --topic TOPIC    Filter by topic"
    echo "  --days N         Search events from last N days"
    echo "  --since DATE     Search events since ISO date (overrides --days)"
    echo "  -h, --help       Show this help message"
    echo ""
    echo "Search across knowledge events for matching content"
}

# Check for background analysis results
ks_check_background_results || true

# Default values
SEARCH_TERM=""
TYPE_FILTER=""
TOPIC_FILTER=""
DAYS=""
SINCE=""

# First check for help or if no arguments
if [[ $# -eq 0 ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
    usage
    exit 0
fi

# Extract search term (first non-option argument)
TEMP_ARGS=()
for arg in "$@"; do
    if [[ "$arg" != --* ]] && [[ "$arg" != -* ]]; then
        if [[ -z "$SEARCH_TERM" ]]; then
            SEARCH_TERM="$arg"
        else
            TEMP_ARGS+=("$arg")
        fi
    else
        TEMP_ARGS+=("$arg")
    fi
done

if [[ -z "$SEARCH_TERM" ]]; then
    echo "Error: Search term is required" >&2
    usage >&2
    exit 1
fi

# Parse remaining arguments using GNU getopt
PARSED=$(ks_parse_options "kq" "d:s:t:T:" "days:,since:,type:,topic:" "${TEMP_ARGS[@]}") || {
    usage >&2
    exit 1
}

eval set -- "$PARSED"

# Process options
while true; do
    case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -d|--days)
            ks_handle_days "$2"
            shift 2
            ;;
        -s|--since)
            ks_handle_since "$2"
            shift 2
            ;;
        -t|--type)
            TYPE_FILTER="$2"
            shift 2
            ;;
        -T|--topic)
            TOPIC_FILTER="$2"
            shift 2
            ;;
        --)
            shift
            break
            ;;
        *)
            ks_unknown_option "$1"
            ;;
    esac
done

# Get filter date if time filtering is requested
filter_date=""
if [[ -n "$DAYS" ]] || [[ -n "$SINCE" ]]; then
    filter_date=$(ks_get_filter_date "$DAYS" "$SINCE")
fi

# Build jq filter
JQ_FILTER="."

if [[ -n "$filter_date" ]]; then
    JQ_FILTER="$JQ_FILTER | select(.ts >= \"$filter_date\")"
fi

if [[ -n "$TYPE_FILTER" ]]; then
    JQ_FILTER="$JQ_FILTER | select(.type == \"$TYPE_FILTER\")"
fi

if [[ -n "$TOPIC_FILTER" ]]; then
    JQ_FILTER="$JQ_FILTER | select(.metadata.topic == \"$TOPIC_FILTER\")"
fi

# Collect files
if [[ -n "$filter_date" ]]; then
    ks_collect_files_since "$filter_date"
else
    ks_collect_files
fi

# Perform search with single jq call if files exist
if [[ ${#FILES_TO_PROCESS[@]} -gt 0 ]]; then
    jq -r --arg search_term "$SEARCH_TERM" "$JQ_FILTER | select(.thought // .observation // .question // .content // \"\" | test(\$search_term; \"i\")) | \"\(.ts) [\(.type)/\(.metadata.topic // \"none\")] \(.thought // .observation // .question // .content // \"empty\")\"" "${FILES_TO_PROCESS[@]}" 2>/dev/null || true
fi