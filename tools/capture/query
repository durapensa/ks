#!/usr/bin/env bash

# query - Search and filter knowledge events (declarative version)

set -euo pipefail

# Source configuration and modular libraries
source "${0%/*}/../../.ks-env"
source "$KS_ROOT/lib/core.sh"
source "$KS_ROOT/lib/files.sh"
source "$KS_ROOT/lib/time.sh"
source "$KS_ROOT/lib/error.sh"
source "$KS_ROOT/lib/usage.sh"

# Standardized usage function
usage() {
    declare -a arguments=(
        "SEARCH_TERM        Text to search for (optional)"
    )
    declare -a examples=(
        "query memory"
        "query --days 7 \"learning\""
        "query --type thought --topic productivity"
    )
    ks_generate_usage \
        "Search and filter knowledge events" \
        "query" \
        "[options] [SEARCH_TERM]" \
        "CAPTURE_SEARCH" \
        arguments \
        examples
}

# Build getopt options
LONG_OPTS="help"
LONG_OPTS="${LONG_OPTS},days:"
LONG_OPTS="${LONG_OPTS},since:"
LONG_OPTS="${LONG_OPTS},type:"
LONG_OPTS="${LONG_OPTS},topic:"
LONG_OPTS="${LONG_OPTS},limit:"
LONG_OPTS="${LONG_OPTS},reverse"
LONG_OPTS="${LONG_OPTS},count"

# Parse options with getopt (dummy -o h required for long options)
OPTS=$($KS_GETOPT -o h -l "$LONG_OPTS" -- "$@") || ks_exit_usage "Invalid options provided"
eval set -- "$OPTS"

# Process options
while true; do
    case "$1" in
        --help) usage; exit 0 ;;
        --days) DAYS="$2"; shift 2 ;;
        --since) SINCE="$2"; shift 2 ;;
        --type) TYPE="$2"; shift 2 ;;
        --topic) TOPIC="$2"; shift 2 ;;
        --limit) LIMIT="$2"; shift 2 ;;
        --reverse) REVERSE=true; shift ;;
        --count) COUNT=true; shift ;;
        --) shift; break ;;
        *) ks_exit_error "Internal argument parsing error" ;;
    esac
done

# Apply defaults and initialize variables
DAYS="${DAYS:-}"
SINCE="${SINCE:-}"
TYPE="${TYPE:-}"
TOPIC="${TOPIC:-}"
LIMIT="${LIMIT:-20}"
REVERSE="${REVERSE:-}"
COUNT="${COUNT:-}"

# Get the search term from remaining arguments
SEARCH_TERM="${1:-}"

# Get filter date
FILTER_DATE=$(ks_get_filter_date "$DAYS" "$SINCE")

# Collect files
ks_collect_files_since "$FILTER_DATE"

[[ ${#FILES_TO_PROCESS[@]} -eq 0 ]] && { echo "No events found"; exit $EXIT_SUCCESS; }

# Build the jq filter
FILTER=".ts >= \"$FILTER_DATE\""

# Add filters
[[ -n "$TYPE" ]] && FILTER="$FILTER and .type == \"$TYPE\""
[[ -n "$TOPIC" ]] && FILTER="$FILTER and .metadata.topic == \"$TOPIC\""
[[ -n "$SEARCH_TERM" ]] && FILTER="$FILTER and (tostring | test(\"$SEARCH_TERM\"; \"i\"))"

# Prepare for counting or normal output
COUNT_FLAG=""
[[ "$COUNT" == "true" ]] && COUNT_FLAG="-s"

# Build sort option
SORT_CMD="sort -n"
[[ "$REVERSE" == "true" ]] && SORT_CMD="sort -nr"

# Process files
{
    for file in "${FILES_TO_PROCESS[@]}"; do
        if [[ -f "$file" && -s "$file" ]]; then
            jq $COUNT_FLAG -r "select($FILTER) | \"\\(.ts // \"unknown\"): \\(.type // \"unknown\") - \\(.thought // .observation // .question // .content // \"empty\")\"" "$file" 2>/dev/null || true
        fi
    done
} | if [[ "$COUNT" == "true" ]]; then
    # Count mode
    wc -l | tr -d ' '
else
    # Normal mode
    $SORT_CMD | head -n "$LIMIT"
fi