#!/usr/bin/env bash
# Curate duplicate knowledge to prevent KG pollution (declarative version)

set -euo pipefail

# Source environment and libraries
source "${0%/*}/../../.ks-env"
source "$KS_ROOT/lib/core.sh"
source "$KS_ROOT/lib/argparse.sh"
source "$KS_ROOT/tools/lib/queue.sh"

# Define command description
ks_define_usage "Analyze content for redundancy against existing knowledge to prevent
knowledge graph pollution with similar or duplicate insights.

Exit codes:
  0 - Content is unique, safe to add
  1 - Content is redundant, should not be added
  2 - Error in analysis

Examples:
  ${0##*/} --content \"Memory systems analysis\" --type themes
  ${0##*/} --threshold 0.8 --content \"Temporal knowledge patterns\"
  echo \"New insight\" | ${0##*/} --type insights"

# Check for background analysis results
ks_check_background_results || true

# Configuration defaults
SIMILARITY_THRESHOLD="${KS_SIMILARITY_THRESHOLD:-0.7}"
CURATION_WINDOW="${KS_CURATION_WINDOW:-30}"

# Handler for threshold validation
ks_handle_threshold() {
    local threshold="$1"
    if ! echo "$threshold" | rg -q '^[0-9]*\.?[0-9]+$'; then
        ks_error "Threshold must be a decimal number between 0.0 and 1.0"
        exit 2
    fi
    THRESHOLD="$threshold"
}

# Initialize and define options
ks_init_options
ks_example "--content \"Memory systems analysis\" --type themes"
ks_example "--threshold 0.8 --content \"Temporal knowledge patterns\""
ks_option "content" "c" "Content to check for duplicates" "" ""
ks_option "type" "t" "Knowledge type: themes, connections, insights" "general" ""
ks_option "threshold" "" "Similarity threshold (0.0-1.0)" "$SIMILARITY_THRESHOLD" "ks_handle_threshold"
ks_option "window" "w" "Days to check back for duplicates" "$CURATION_WINDOW" ""
ks_option "sources" "s" "Specific sources to check (comma-separated)" "" ""
ks_option "verbose" "v" "Show detailed similarity analysis" "" "" "flag"

# Process options
ks_process_options "$@"

# Get content from option, positional arg, or stdin
CONTENT="${CONTENT:-}"
if [[ -z "$CONTENT" && ${#REMAINING_ARGS[@]} -gt 0 ]]; then
    CONTENT="${REMAINING_ARGS[0]}"
fi

if [[ -z "$CONTENT" ]]; then
    if [[ -t 0 ]]; then
        ks_error "No content provided and stdin is empty"
        usage
        exit 2
    fi
    CONTENT=$(cat)
fi

# Validate content
if [[ -z "$CONTENT" ]]; then
    ks_error "Content cannot be empty"
    exit 2
fi

# Extract key terms from content for comparison
extract_key_terms() {
    local text="$1"
    # Extract words, convert to lowercase, filter meaningful terms (3+ chars)
    echo "$text" | rg -o '[a-zA-Z]{3,}' | tr '[:upper:]' '[:lower:]' | sort -u
}

# Calculate term overlap similarity
calculate_similarity() {
    local content1="$1"
    local content2="$2"
    
    local terms1=$(extract_key_terms "$content1")
    local terms2=$(extract_key_terms "$content2")
    
    if [[ -z "$terms1" ]] || [[ -z "$terms2" ]]; then
        echo "0.0"
        return
    fi
    
    # Count common terms
    local common_count=$(comm -12 <(echo "$terms1") <(echo "$terms2") | wc -l)
    local total_terms1=$(echo "$terms1" | wc -l)
    local total_terms2=$(echo "$terms2" | wc -l)
    
    # Use Jaccard similarity: intersection / union
    local union_count=$((total_terms1 + total_terms2 - common_count))
    
    if [[ "$union_count" -eq 0 ]]; then
        echo "0.0"
    else
        echo "scale=3; $common_count / $union_count" | bc -l
    fi
}

# Check against recent notifications
check_recent_findings() {
    local content="$1"
    local knowledge_type="$2"
    
    if [[ "${VERBOSE:-}" == "true" ]]; then
        echo "Checking against recent analysis findings..." >&2
    fi
    
    # Get pending analyses from queue
    local pending=$(ks_queue_list_pending)
    
    if [[ "$pending" == "[]" ]]; then
        if [[ "${VERBOSE:-}" == "true" ]]; then
            echo "No pending analyses to check against" >&2
        fi
        return 0
    fi
    
    # Check each pending analysis
    echo "$pending" | jq -c '.[]' | while IFS= read -r analysis; do
        local findings_file=$(echo "$analysis" | jq -r '.value.findings_file')
        
        if [[ -f "$findings_file" ]]; then
            local findings=$(jq -r '.findings[]? // .[]' "$findings_file" 2>/dev/null)
            local existing_content=$(echo "$findings" | jq -r '.content // .theme // .insight // .pattern // ""' | tr '\n' ' ')
            
            if [[ -n "$existing_content" ]]; then
                local similarity=$(calculate_similarity "$content" "$existing_content")
                
                if [[ "${VERBOSE:-}" == "true" ]]; then
                    echo "Similarity with pending findings: $similarity" >&2
                fi
                
                if (( $(echo "$similarity > $THRESHOLD" | bc -l) )); then
                    echo "Content is redundant (similarity: $similarity with pending findings)"
                    return 1
                fi
            fi
        fi
    done
    
    return 0
}

# Check against derived knowledge
check_derived_knowledge() {
    local content="$1"
    local knowledge_type="$2"
    
    if [[ "${VERBOSE:-}" == "true" ]]; then
        echo "Checking against derived knowledge..." >&2
    fi
    
    # Check appropriate derived directory
    local derived_dir="$KS_DERIVED_DIR"
    case "$knowledge_type" in
        themes)
            derived_dir="$KS_DERIVED_DIR/concepts"
            ;;
        connections)
            derived_dir="$KS_DERIVED_DIR/connections"
            ;;
        insights)
            derived_dir="$KS_DERIVED_DIR/insights"
            ;;
    esac
    
    if [[ ! -d "$derived_dir" ]]; then
        if [[ "${VERBOSE:-}" == "true" ]]; then
            echo "No derived directory found: $derived_dir" >&2
        fi
        return 0
    fi
    
    # Check recent derived content
    local derived_files=$(find "$derived_dir" -name "*.md" -mtime -$WINDOW 2>/dev/null || true)
    
    for file in $derived_files; do
        if [[ -f "$file" ]]; then
            local existing_content=$(cat "$file")
            local similarity=$(calculate_similarity "$content" "$existing_content")
            
            if [[ "${VERBOSE:-}" == "true" ]]; then
                echo "Similarity with $(basename "$file"): $similarity" >&2
            fi
            
            if (( $(echo "$similarity > $THRESHOLD" | bc -l) )); then
                echo "Content is redundant (similarity: $similarity with derived knowledge: $(basename "$file"))"
                return 1
            fi
        fi
    done
    
    return 0
}

# Main curation logic
main() {
    if [[ "${VERBOSE:-}" == "true" ]]; then
        echo "Curating content: $(echo "$CONTENT" | head -c 50)..." >&2
        echo "Type: $TYPE, Threshold: $THRESHOLD" >&2
    fi
    
    # Check against recent findings
    if ! check_recent_findings "$CONTENT" "$TYPE"; then
        exit 1
    fi
    
    # Check against derived knowledge
    if ! check_derived_knowledge "$CONTENT" "$TYPE"; then
        exit 1
    fi
    
    if [[ "${VERBOSE:-}" == "true" ]]; then
        echo "Content is unique and safe to add." >&2
    else
        echo "Content is unique."
    fi
    
    exit 0
}

# Dependency check
if ! command -v bc > /dev/null; then
    ks_error "bc (calculator) is required for similarity calculations"
    exit 2
fi

main